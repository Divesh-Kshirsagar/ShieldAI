{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SHIELD AI","text":"<p>Real-time industrial discharge anomaly detection for CETP compliance.</p> <p>SHIELD AI monitors 1-minute frequency sensor streams from a Common Effluent Treatment Plant (CETP), detects COD shock-load events, reverse-temporally joins factory discharge streams to pinpoint the rogue factory, and surfaces evidence via a Streamlit dashboard and an un-falsifiable JSONL audit log.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>uv sync                                    # install dependencies\nuv run python src/simulate_factories.py    # generate factory data (once)\nuv run python src/run_pipeline.py          # start attribution pipeline\nuv run streamlit run app.py               # dashboard \u2192 localhost:8501\nuv run uvicorn src.api:app --reload        # MPCB API stub \u2192 localhost:8000/docs\n</code></pre>"},{"location":"#key-claims","title":"Key Claims","text":"Claim Status Detects CETP COD breach in real time \u2705 verified (206 breach events in real data) Attributes discharge to upstream factory \u2705 verified (factory_B at 447 mg/L, T-15min) Detects digital tampering (zero-variance) \ud83d\udd32 v2 stub in <code>anti_cheat.py</code> MPCB API v2.3 compliance shape \u2705 mirrored in <code>api.py</code>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Architecture \u2014 system design and data flow</li> <li>Methodology \u2014 approach and design decisions</li> <li>Assumptions \u2014 explicit engineering assumptions</li> <li>Math \u2014 equations and derivations</li> <li>ML Roadmap \u2014 future ML extensions</li> <li>MPCB API Reference \u2014 original API spec</li> </ul>"},{"location":"MpcbApi/","title":"MPCB Central Server Software Open API v2.3 Documentation","text":""},{"location":"MpcbApi/#general-api-requirements","title":"General API Requirements","text":"<ul> <li> <p>Base URL: <code>http://&lt;ipaddress:port&gt;/MPCBServer</code> </p> </li> <li> <p>Protocol: HTTP-based REST Service </p> </li> <li> <p>Authentication: All requests must be authenticated. Unauthenticated requests are discarded.</p> </li> <li> <p>Data Frequencies: Analyser sampling should occur every 10 seconds. Data transmission to the server must occur at a 1-minute frequency.</p> </li> <li> <p>Data Components: Transmissions must include raw data, linearized data, data quality codes, and captured timestamps.</p> </li> <li> <p>Site Restriction: Data must be transmitted directly from the site location; other locations will be rejected.</p> </li> </ul>"},{"location":"MpcbApi/#authentication-headers","title":"Authentication Headers","text":"<p>Every API request header must include:</p> <ul> <li> <p>Timestamp: Configurable, but must not be older than 15 minutes from the current timestamp.</p> </li> <li> <p>Authorization: An encrypted digest generated just before transmission using the Site Private Key. The digest must contain:</p> </li> <li> <p><code>site_id</code>: Unique authentication ID provided by MPCB.</p> </li> <li> <p><code>software_version_id</code>: Version set and registered by the Central Server (not dependent on client software version).</p> </li> <li> <p><code>time_stamp_data</code>: Timestamp of encryption.</p> </li> </ul>"},{"location":"MpcbApi/#1-data-upload-real-time-delayed","title":"1. Data Upload (Real Time &amp; Delayed)","text":"<p>Uploads site data to the server. If upload is successful, the client software must read subsequent instruction flags in the response.</p> <ul> <li>Routes:</li> <li> <p><code>/realtimeUpload</code> (For data captured during the last poll frequency / max 2 min delay) </p> </li> <li> <p><code>/delayedUpload</code> (For data delayed beyond 15 minutes due to communication failure) </p> </li> <li> <p>Method: POST </p> </li> <li> <p>Request Format: <code>multipart/form-data</code> containing a zipped file.</p> </li> <li> <p>Payload Requirements:</p> </li> <li> <p>The zip file must contain two files: a Data File and a Metadata File.</p> </li> <li> <p>The Data File must be encrypted using the Site Private Key and follow ISO-7168 format, simplified delimited, or fixed-width.</p> </li> <li> <p>The Metadata File specifies the file specification/format.</p> </li> <li> <p>The header must contain the encryption digest.</p> </li> </ul> <p>Success Response JSON:</p> <pre><code>{\n  \"status\": \"Success\",\n  \"serverConfigLastUpdatedTime\": \"&lt;time&gt;\",\n  \"ConfigurationDownloadFlag\": \"&lt;True/False&gt;\",\n  \"ConfigurationUpdateFlag\": \"&lt;True/False&gt;\",\n  \"RemoteCalibrationUpdateFlag\": \"&lt;True/False&gt;\",\n  \"DiagnosticUpdateFlag\": \"&lt;True/False&gt;\",\n  \"statusMessage\": \"file uploaded successfully.\"\n}\n</code></pre> <p>Failure Response JSON:</p> <pre><code>{\n  \"status\": \"Failed\",\n  \"statusMessage\": \"No files were uploaded.\"\n}\n</code></pre>"},{"location":"MpcbApi/#2-configuration-download","title":"2. Configuration Download","text":"<p>Triggered when the <code>ConfigurationDownloadFlag</code> is set to \"True\" in the Data Upload response. Downloads the entire station configuration to sync with the analyser.</p> <ul> <li> <p>Route: <code>/getConfig</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON:</p> <pre><code>{\n  \"siteId\": \"&lt;site-id&gt;\",\n  \"monitoringid\": \"&lt;monitor-id&gt;\"\n}\n</code></pre> <p>Response JSON (Success):</p> <pre><code>{\n  \"status\": \"Success\",\n  \"serverConfigLastUpdatedTime\": \"&lt;ServerConfigUpdatedLastTime&gt;\",\n  \"SiteDetails\": {\n    \"siteName\": \"&lt;SiteName&gt;\",\n    \"siteLabel\": \"&lt;SiteLabel&gt;\",\n    \"siteConfigLastUpdatedTime\": \"&lt;SiteConfigUpdatedLastTime&gt;\",\n    \"siteId\": \"&lt;site id&gt;\",\n    \"customparameters\": {}\n  },\n  \"CollectorDetails\": [{\n    \"CollectorType\": \"&lt;&gt;\",\n    \"CollectorName\": \"&lt;&gt;\",\n    \"ConfiguredChannels\": \"&lt;&gt;\",\n    \"PollingStep\": \"&lt;polling step&gt;\",\n    \"ChecksumStatusBit\": \"&lt;checksum bit&gt;\",\n    \"Address\": \"&lt;address&gt;\",\n    \"HeartBeat\": \"&lt;heartbeat&gt;\",\n    \"DataFormatBits\": \"00\",\n    \"Port\": \"&lt;port&gt;\",\n    \"CommunicationTimeOut\": \"&lt;communication bit&gt;\",\n    \"customparameters\": {}\n  }],\n  \"configJson\": {\n    \"monitoringType\": { \"required\": \"True\", \"padding\": \"-\", \"start_pos\": 55, \"end_pos\": 64, \"type\": \"string\", \"alignment\": \"left\" },\n    \"monitoringId\": { \"required\": \"True\", \"padding\": \"-\", \"start_pos\": 65, \"end_pos\": 84, \"type\": \"string\", \"alignment\": \"left\" },\n    \"QualityCode\": { \"required\": \"True\", \"padding\": \"*\", \"start_pos\": 42, \"end_pos\": 43, \"type\": \"string\", \"alignment\": \"left\" },\n    \"SensorTime\": { \"required\": \"True\", \"padding\": \"-\", \"start_pos\": 44, \"end_pos\": 54, \"type\": \"string\", \"alignment\": \"left\" },\n    \"parameterId\": { \"required\": \"True\", \"padding\": \"-\", \"start_pos\": 85, \"end_pos\": 100, \"type\": \"string\", \"alignment\": \"left\" },\n    \"parameterName\": { \"required\": \"True\", \"padding\": \"\", \"start_pos\": 11, \"end_pos\": 25, \"type\": \"string\", \"alignment\": \"left\" },\n    \"Reading\": { \"required\": \"True\", \"padding\": \"*\", \"start_pos\": 26, \"end_pos\": 41, \"type\": \"string\", \"alignment\": \"left\" },\n    \"id\": { \"required\": \"True\", \"padding\": \"-\", \"start_pos\": 1, \"end_pos\": 8, \"type\": \"string\", \"alignment\": \"left\" },\n    \"sensorChannel\": { \"required\": \"True\", \"padding\": \"\", \"start_pos\": 9, \"end_pos\": 10, \"type\": \"string\", \"alignment\": \"left\" },\n    \"analyzerId\": { \"required\": \"True\", \"padding\": \"\", \"start_pos\": 101, \"end_pos\": 115, \"type\": \"string\", \"alignment\": \"left\" }\n  },\n  \"AcquisitionSystemDetails\": {\n    \"AcquisitionVersion\": \"&lt;Version Number&gt;\",\n    \"AcquisitionSystem\": \"&lt;Acquisition System Name&gt;\"\n  },\n  \"SensorA\": {\n    \"collectorType\": \"&lt;Monitoring Type&gt;\",\n    \"monitoringType\": \"&lt;Monitoring Type&gt;\",\n    \"monitoringId\": \"&lt;Monitoring Id&gt;\",\n    \"ChannelNo\": \"0\",\n    \"GaugeMinimum\": \"\",\n    \"CoefficientA\": \"\",\n    \"parameterId\": \"&lt;parameter id&gt;\",\n    \"GaugeMaximum\": \"\",\n    \"MeasurementUnit\": \"&lt;measurement unit&gt;\",\n    \"compPort\": \"\",\n    \"parameterName\": \"&lt;parameter name&gt;\",\n    \"CoefficientB\": \"\",\n    \"analyzerId\": \"&lt;analyzer id&gt;\",\n    \"customparameters\": {}\n  }\n}\n</code></pre>"},{"location":"MpcbApi/#3-fetch-configuration-from-client","title":"3. Fetch Configuration From Client","text":"<p>Triggered when <code>ConfigurationUpdateFlag</code> is set to \"True\". The client uploads its current analyser configuration to the server.</p> <ul> <li> <p>Route: <code>/uploadConfig</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON: Matches the exact schema of the <code>/getConfig</code> response, but wrapped with a Command key.</p> <pre><code>{\n  \"Command\": \"ConfigFetch\",\n  \"serverConfigLastUpdatedTime\": \"&lt;ServerConfigUpdatedLastTime&gt;\",\n  \"SiteDetails\": {\n    \"siteName\": \"&lt;SiteName&gt;\",\n    \"siteLabel\": \"&lt;SiteLabel&gt;\",\n    \"siteConfigLastUpdatedTime\": \"&lt;SiteConfigUpdatedLastTime&gt;\",\n    \"siteId\": \"&lt;site id&gt;\",\n    \"monitoringId\": \"&lt;monitoring id&gt;\",\n    \"customparameters\": {}\n  },\n  \"CollectorDetails\": [ { \"...\" } ],\n  \"configJson\": { \"...\" },\n  \"AcquisitionSystemDetails\": { \"...\" },\n  \"SensorA\": { \"...\" }\n}\n</code></pre> <p>Response JSON:</p> <pre><code>{\n  \"status\": \"Success\",\n  \"configUpdateStatus\": \"Received Site configuration successfully\"\n}\n</code></pre>"},{"location":"MpcbApi/#4-configuration-update-acknowledgement","title":"4. Configuration Update Acknowledgement","text":"<p>Used by the client to confirm successful receipt and application of configurations from <code>/getConfig</code> . If not sent, the server will continuously set the download flag to \"True\".</p> <ul> <li> <p>Route: <code>/completedConfig</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON:</p> <pre><code>{\n  \"siteId\": \"&lt;site-id&gt;\",\n  \"monitoringid\": \"&lt;monitor-id&gt;\",\n  \"ConfigUpdated\": \"True\"\n}\n</code></pre> <p>Response JSON:</p> <pre><code>{\n  \"status\": \"Success\",\n  \"calibrationUpdateStatus\": \"Server and Site Configuration Synchronized\"\n}\n</code></pre>"},{"location":"MpcbApi/#5-remote-calibration-service","title":"5. Remote Calibration Service","text":"<p>Triggered when <code>RemoteCalibrationUpdateFlag</code> is set to \"True\". Downloads the necessary schedule, parameters, and sequence required for local calibrators.</p> <ul> <li> <p>Route: <code>/getcalibrationconfig</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON:</p> <pre><code>{\n  \"siteId\": \"&lt;site-id&gt;\",\n  \"monitoringid\": \"&lt;monitor-id&gt;\",\n  \"CalibrationType\": \"&lt;Scheduled or Immediate&gt;\"\n}\n</code></pre> <p>Response JSON:</p> <p>(Note: Custom parameters can be added via the \"customparameters\" tag if required by analyser makers) </p> <pre><code>{\n  \"status\": \"Success\",\n  \"calibration\": {\n    \"calibratorName\": \"&lt;calibrator-name&gt;\",\n    \"sequence\": [{\n      \"function\": \"&lt;function name&gt;\",\n      \"duration_secs\": \"&lt;duration in seconds&gt;\",\n      \"gas\": \"&lt;gas&gt;\",\n      \"value\": \"0\",\n      \"delay\": \"&lt;delay in minutes&gt;\",\n      \"sequenceName\": \"&lt;sequence name&gt;\",\n      \"duration\": \"&lt;duration in minute&gt;\",\n      \"type\": \"&lt;type of calibration&gt;\",\n      \"unit\": \"&lt;unit of gas&gt;\"\n    }],\n    \"siteName\": \"&lt;site name&gt;\",\n    \"monitoringType\": \"&lt;monitoring type&gt;\",\n    \"frequency\": \"&lt;frequency&gt;\",\n    \"analyzerId\": \"&lt;analyser id&gt;\",\n    \"parameterId\": \"&lt;parameter id&gt;\",\n    \"remoteCalibrationId\": \"&lt;remote calibration id&gt;\",\n    \"parameterName\": \"SO2\",\n    \"cycleUnit\": \"1\",\n    \"total_duration\": \"&lt;total duration&gt;\",\n    \"frequencyDay\": \"&lt;day&gt;\",\n    \"siteId\": \"&lt;site id&gt;\",\n    \"startTime\": { \"date\": \"&lt;date&gt;\", \"time\": \"&lt;time&gt;\" },\n    \"execute_Immediate\": \"True\",\n    \"day\": \"&lt;day&gt;\",\n    \"cycle\": \"&lt;cycle&gt;\",\n    \"frequencyTime\": \"&lt;frequency time&gt;\",\n    \"calibratorId\": \"&lt;calibration id&gt;\",\n    \"monitoringUnit\": \"&lt;monitoring unit&gt;\",\n    \"value\": \"\",\n    \"channelNumber\": \"&lt;channel number&gt;\",\n    \"analyzerType\": \"&lt;analyser type&gt;\",\n    \"endTime\": { \"date\": \"&lt;date&gt;\", \"time\": \"&lt;time&gt;\" },\n    \"remoteCalibrationName\": \"&lt;remote calibration name&gt;\",\n    \"analyzerName\": \"&lt;analyser name&gt;\",\n    \"serverCalibrationLastUpdatedTime\": \"&lt;serverCalibrationLastUpdatedTime&gt;\",\n    \"siteCalibrationLastUpdatedTime\": \"&lt;siteCalibrationLastUpdatedTime&gt;\",\n    \"lastCalibratedOn\": \"&lt;lastCalibratedon&gt;\"\n  }\n}\n</code></pre>"},{"location":"MpcbApi/#6-calibration-update-acknowledgement","title":"6. Calibration Update Acknowledgement","text":"<p>Confirms the calibration sequence was successfully downloaded and scheduled locally.</p> <ul> <li> <p>Route: <code>/updatecalibrationconfig</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON:</p> <pre><code>{\n  \"siteId\": \"&lt;site-id&gt;\",\n  \"monitoringid\": \"&lt;monitor-id&gt;\",\n  \"CalibrationType\": \"&lt;Scheduled or Immediate&gt;\"\n}\n</code></pre> <p>Response JSON:</p> <pre><code>{\n  \"status\": \"Success\",\n  \"calibrationUpdateStatus\": \"Server and Site Calibration Synchronized\"\n}\n</code></pre>"},{"location":"MpcbApi/#7-diagnostic-information-upload","title":"7. Diagnostic Information Upload","text":"<p>Triggered when <code>DiagnosticUpdateFlag</code> is set to \"True\". Uploads internal state and diagnostic information of the analyser.</p> <ul> <li> <p>Route: <code>/uploadDiagnosticInfo</code> </p> </li> <li> <p>Method: POST </p> </li> </ul> <p>Request JSON:</p> <pre><code>{\n  \"Command\": \"DiagnosticFetch\",\n  \"SiteDetails\": {\n    \"siteName\": \"&lt;SiteName&gt;\",\n    \"siteLabel\": \"&lt;SiteLabel&gt;\",\n    \"siteConfigLastUpdatedTime\": \"&lt;SiteConfigUpdatedLastTime&gt;\",\n    \"siteId\": \"&lt;site id&gt;\",\n    \"monitoringId\": \"&lt;monitoring id&gt;\",\n    \"customparameters\": {}\n  },\n  \"CollectorDetails\": [{\n    \"CollectorType\": \"&lt;&gt;\",\n    \"CollectorName\": \"&lt;&gt;\",\n    \"ConfiguredChannels\": \"&lt;&gt;\",\n    \"PollingStep\": \"&lt;polling step&gt;\",\n    \"ChecksumStatusBit\": \"&lt;checksum bit&gt;\",\n    \"Address\": \"&lt;address&gt;\",\n    \"HeartBeat\": \"&lt;heartbeat&gt;\",\n    \"DataFormatBits\": \"00\",\n    \"Port\": \"&lt;port&gt;\",\n    \"CommunicationTimeOut\": \"&lt;communication bit&gt;\",\n    \"customparameters\": {}\n  }],\n  \"diagnosticJson\": [{\n    \"analyserId\": \"&lt;analyser-id&gt;\",\n    \"parameterName\": \"\",\n    \"diagnostics\": [{\n      \"key\": \"&lt;key&gt;\",\n      \"value\": \"&lt;value&gt;\",\n      \"category\": \"&lt;category&gt;\"\n    }]\n  }]\n}\n</code></pre> <p>Response JSON:</p> <pre><code>{\n  \"status\": \"Success\",\n  \"diagnosticUpdateStatus\": \"Received Site diagnostics successfully\"\n}\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>flowchart TD\n    A[\"priya_cetp_i.csv (real)\"] --&gt; B[\"ingest.py\\nMPCB col rename\\nNA \u2192 null float\"]\n    C[\"factory_A/B/C/D.csv (simulated)\"] --&gt; D[\"ingest.py\\nNA \u2192 BLACKOUT\"]\n    B --&gt; E[\"tripwire.py\\nCOD \u2265 threshold\\n\u2192 shock_events\"]\n    D --&gt; F[\"aggregate.py\\nunified stream\"]\n    F --&gt; G[\"backtrack.py\\nbuild_factory_index()\"]\n    E --&gt; H[\"alert.py\\npw.io.subscribe callback\\nattribute_event()\"]\n    G --&gt; H\n    H --&gt; I[\"evidence_log.jsonl\\nappend-only\"]\n    I --&gt; J[\"app.py\\nStreamlit dashboard\"]</code></pre>"},{"location":"architecture/#data-flow-attribution","title":"Data Flow: Attribution","text":"<pre><code>flowchart LR\n    A[\"CETP spike detected at T\"] --&gt; B[\"T_backtrack = T \u2212 15 min\"]\n    B --&gt; C[\"Scan factory_index\\nfor rows within \u00b12 min\"]\n    C --&gt; D{\"Any matches?\"}\n    D -- Yes --&gt; E[\"Select MAX cod row\\n\u2192 attributed_factory\"]\n    D -- No --&gt; F[\"attributed_factory = None\"]\n    E --&gt; G[\"Append to\\nevidence_log.jsonl\"]\n    F --&gt; G</code></pre>"},{"location":"architecture/#streaming-design","title":"Streaming Design","text":"<pre><code>flowchart LR\n    subgraph Pathway[\"Pathway Streaming Graph\"]\n        P1[\"pw.io.csv.read\\nmode=streaming\\nCETP CSV\"] --&gt; P2[\"tripwire filter\\ncod &gt;= threshold\"]\n        P2 --&gt; P3[\"pw.io.subscribe\\ncallback\"]\n    end\n\n    subgraph Pandas[\"Pandas (Eager, Static)\"]\n        Q1[\"build_factory_index()\\nloads all factory CSVs once\"] --&gt; Q2[\"attribute_event()\\nfor each shock event\"]\n    end\n\n    P3 --&gt; Q2\n    Q2 --&gt; R[\"evidence_log.jsonl\"]</code></pre>"},{"location":"architecture/#module-responsibilities","title":"Module Responsibilities","text":"Module Role Key Output <code>simulate_factories.py</code> Generate 4 test factory CSVs from CETP timeline <code>data/factories/</code>, <code>data/cetp/cetp_clean.csv</code> <code>ingest.py</code> Pathway streaming read, MPCB column rename, NA/BLACKOUT tagging <code>pw.Table</code> (CETP + factory) <code>aggregate.py</code> Convenience wrapper to unify factory stream <code>pw.Table</code> <code>tripwire.py</code> COD threshold filter \u2192 shock events <code>pw.Table</code> (shock_events) <code>backtrack.py</code> Pandas factory index + nearest-timestamp attribution <code>dict</code> (evidence record) <code>alert.py</code> <code>pw.io.subscribe</code> callback: runs backtrack, writes JSONL, fires webhook <code>evidence_log.jsonl</code> <code>anti_cheat.py</code> Pandas tumbling-window: zero-variance, fingerprint, blackout detection <code>tamper_log.jsonl</code> <code>api.py</code> FastAPI stub of MPCB Open API v2.3 (8 endpoints) REST API <code>app.py</code> Streamlit dashboard UI <code>constants.py</code> Single source of truth for all tuneable parameters \u2014"},{"location":"assumptions/","title":"Assumptions","text":"<p>This page documents every explicit engineering assumption made in the Phase 1 prototype. Each assumption should be revisited before a production deployment.</p>"},{"location":"assumptions/#a1-fixed-pipe-travel-time","title":"A1 \u2014 Fixed Pipe Travel Time","text":"<p>Assumed value: 15 minutes (<code>PIPE_TRAVEL_MINUTES</code> in <code>constants.py</code>)</p> <p>Basis: Expert estimate for a typical CETP catchment area where factories are within 1\u20133 km of the CETP inlet via gravity-fed sewers at ~0.6 m/s flow velocity.</p> <p>Impact: Every temporal backtrack is shifted by exactly this value. An incorrect estimate shifts all attributions earlier or later, potentially pointing at the wrong factory or missing the event window.</p> <p>Production fix (v2): Replace with a dynamic calculation: <pre><code>T_travel = \u03a3(pipe_segment_length / flow_velocity_from_SCADA)\n</code></pre> derived from GIS pipe network data and real-time flow-rate sensors at junctions.</p>"},{"location":"assumptions/#a2-cod-is-the-primary-detection-metric","title":"A2 \u2014 COD is the Primary Detection Metric","text":"<p>Assumed: BOD, pH, TSS are available but only COD drives the Tripwire alarm.</p> <p>Basis: COD has the fastest response time at 1-minute sensor cadence. BOD requires a 5-day incubation (lab measurement), making it unsuitable for real-time use. pH and TSS are retained for corroborating evidence but not for primary detection.</p> <p>Production fix: Multi-parameter weighted alarm (COD \u00d7 0.6 + TSS \u00d7 0.3 + pH deviation \u00d7 0.1).</p>"},{"location":"assumptions/#a3-factory-with-highest-cod-at-t_backtrack-is-the-culprit","title":"A3 \u2014 Factory with Highest COD at T_backtrack is the Culprit","text":"<p>Assumed: Among all factories with readings in the \u00b12 min window, the one with the maximum COD value is attributed.</p> <p>Basis: A factory dumping illegally will register a dramatically elevated COD relative to the normal baseline (~120 mg/L). The greedy max rule identifies the clearest statistical outlier.</p> <p>Limitation: If two factories dump simultaneously, only the higher one is attributed.</p> <p>Production fix (v2): Proportional discharge weighting using: - Pipe diameter and connectivity matrix from GIS - Permitted volumetric discharge quotas from MPCB licence database</p>"},{"location":"assumptions/#a4-sensor-fires-every-3-rows","title":"A4 \u2014 Sensor Fires Every ~3 Rows","text":"<p>Assumed: The MPCB SCADA transmits a valid reading every ~3 minutes (not every minute), with NA gaps in between.</p> <p>Basis: Observed in <code>priya_cetp_i.csv</code> \u2014 out of 18,781 rows at 1-min frequency, only ~6,185 have valid COD readings (~1 per 3 rows). This mirrors the MPCB spec where real-time transmission can be interrupted by communication gaps.</p> <p>Impact: Simulated factory CSVs replicate this pattern so test data is representative.</p>"},{"location":"assumptions/#a5-the-cetp-processes-all-upstream-factory-waste","title":"A5 \u2014 The CETP Processes All Upstream Factory Waste","text":"<p>Assumed: Every factory in the catchment area is connected to the same CETP sewer network and their effluent contributes to the CETP inlet readings.</p> <p>Basis: Standard CETP design \u2014 factories within the industrial estate are mandated to connect to the CETP rather than discharge directly.</p> <p>Limitation: Satellite/illegal discharge directly to water bodies bypasses the CETP entirely and is not detectable by this system.</p>"},{"location":"assumptions/#a6-simulated-factories-cover-the-same-date-range-as-real-cetp-data","title":"A6 \u2014 Simulated Factories Cover the Same Date Range as Real CETP Data","text":"<p>Assumed: Factory CSVs span Feb 1\u201324 2026 (same as <code>priya_cetp_i.csv</code>), generated from the same timestamp index.</p> <p>Basis: <code>simulate_factories.py</code> reads the CETP timeline first and generates factory rows for every CETP timestamp.</p> <p>Production fix: In live deployment, factory streams would arrive asynchronously with their own timestamps and would be merged into a unified stream via Pathway's <code>pw.io.csv.read()</code> on the factory sewer monitoring network.</p>"},{"location":"assumptions/#a7-evidence_logjsonl-is-tamper-evident-by-append-only-design","title":"A7 \u2014 <code>evidence_log.jsonl</code> is Tamper-Evident by Append-Only Design","text":"<p>Assumed: The JSONL file, once written, is not modified. Each record is self-contained.</p> <p>Basis: Python's <code>open(..., \"a\")</code> appends a new JSON line per event. Existing lines are never overwritten.</p> <p>Production hardening: Cryptographic signing of each record using a Hardware Security Module (HSM), Merkle tree chaining, or write to an immutable ledger (e.g., blockchain anchor).</p>"},{"location":"math/","title":"Mathematical Foundations","text":""},{"location":"math/#1-cod-threshold-exceedance-tripwire","title":"1. COD Threshold Exceedance (Tripwire)","text":"<p>The Tripwire emits a ShockLoadEvent when:</p> \\[ \\text{COD}_{\\text{CETP,inlet}}(t) \\geq \\theta \\] <p>where:</p> <ul> <li>\\(\\text{COD}_{\\text{CETP,inlet}}(t)\\) is the CETP inlet COD reading at time \\(t\\) (mg/L)</li> <li>\\(\\theta = 200 \\text{ mg/L}\\) (demo threshold; see <code>constants.py</code>)</li> </ul> <p>The breach magnitude is:</p> \\[ \\Delta_{\\text{breach}}(t) = \\text{COD}_{\\text{CETP,inlet}}(t) - \\mu_{\\text{baseline}} \\] <p>where \\(\\mu_{\\text{baseline}} = 193.0 \\text{ mg/L}\\) (empirical mean from Feb 2026 real data).</p> <p>Alert level is classified as:</p> \\[ \\text{AlertLevel} = \\begin{cases} \\text{HIGH} &amp; \\text{if } \\text{COD} \\geq 2\\mu_{\\text{baseline}} \\\\ \\text{MEDIUM} &amp; \\text{otherwise} \\end{cases} \\]"},{"location":"math/#2-temporal-backtracking","title":"2. Temporal Backtracking","text":"<p>Given a ShockLoadEvent at CETP inlet time \\(T\\), the backtrack timestamp is:</p> \\[ T_{\\text{backtrack}} = T - \\tau_{\\text{travel}} \\] <p>where \\(\\tau_{\\text{travel}} = 15 \\text{ min}\\) (pipe travel time constant, v1).</p> <p>The attribution search window is:</p> \\[ W = \\left[ T_{\\text{backtrack}} - \\epsilon,\\; T_{\\text{backtrack}} + \\epsilon \\right] \\] <p>where \\(\\epsilon = 120 \\text{ s}\\) (tolerance, <code>ASOF_TOLERANCE_SECONDS</code>).</p> <p>Attribution rule \u2014 the attributed factory \\(\\hat{f}\\) is:</p> \\[ \\hat{f} = \\arg\\max_{f \\in \\mathcal{F}} \\left\\{ \\text{COD}_{f}(t) \\;\\middle|\\; t \\in W \\right\\} \\] <p>where \\(\\mathcal{F}\\) is the set of all factories with a valid COD reading in window \\(W\\).</p>"},{"location":"math/#3-pipe-travel-time-v1-simplification","title":"3. Pipe Travel Time (v1 simplification)","text":"<p>In v1, \\(\\tau_{\\text{travel}}\\) is a fixed constant. The physically correct formula is:</p> \\[ \\tau_{\\text{travel}} = \\sum_{s \\in \\text{path}} \\frac{L_s}{v_s} \\] <p>where: - \\(L_s\\) = length of pipe segment \\(s\\) (m) - \\(v_s\\) = average effluent flow velocity in segment \\(s\\) (m/s)</p> <p>For a typical industrial estate CETP catchment (1\u20133 km radius, gravity sewers):</p> \\[ v_s \\approx 0.6 \\text{ m/s} \\implies \\tau \\approx \\frac{2000 \\text{ m}}{0.6 \\text{ m/s}} \\approx 55 \\text{ min (max)} \\] <p>The 15-minute default assumes factories are within ~0.5 km of the CETP inlet. Adjust via <code>PIPE_TRAVEL_MINUTES</code>.</p>"},{"location":"math/#4-zero-variance-alarm-v2-stub","title":"4. Zero-Variance Alarm (v2 \u2014 stub)","text":"<p>A sensor is flagged as digitally tampered when its rolling standard deviation over window \\(W_{\\text{var}}\\) equals zero:</p> \\[ \\sigma_{\\text{COD},f}(t, W_{\\text{var}}) = \\sqrt{\\frac{1}{|W_{\\text{var}}|} \\sum_{t' \\in W_{\\text{var}}} \\left(\\text{COD}_{f}(t') - \\bar{\\text{COD}}_{f}\\right)^2} = 0 \\] <p>for \\(|W_{\\text{var}}| \\geq 5\\) consecutive minutes.</p> <p>Since floating-point equality to exactly zero is unreliable, in practice the condition is:</p> \\[ \\sigma_{\\text{COD},f}(t, W_{\\text{var}}) &lt; \\varepsilon_{\\text{float}} \\approx 10^{-6} \\]"},{"location":"math/#5-chemical-fingerprint-v2-stub","title":"5. Chemical Fingerprint (v2 \u2014 stub)","text":"<p>The dilution tampering signal is:</p> \\[ \\text{PHYSICAL\\_TAMPERING} \\iff \\frac{\\text{COD}_{f}(t)}{\\text{COD}_{f}(t - \\Delta)} &lt; (1 - \\alpha) \\;\\text{ AND }\\; \\frac{\\text{TSS}_{f}(t)}{\\text{TSS}_{f}(t - \\Delta)} &gt; (1 - \\beta) \\] <p>where: - \\(\\alpha = 0.80\\) \u2014 COD must drop by \u2265 80% (<code>COD_DROP_FRACTION</code>) - \\(\\beta = 0.20\\) \u2014 TSS must remain within 20% of prior value (<code>TSS_STABLE_FRACTION</code>) - \\(\\Delta = 15 \\text{ min}\\) rolling window</p> <p>This captures the bucket trick: adding clean water drops COD (dilution) but particles (TSS) remain.</p>"},{"location":"methodology/","title":"Methodology","text":""},{"location":"methodology/#approach-historical-data-as-a-live-stream","title":"Approach: Historical Data as a Live Stream","text":"<p>SHIELD AI demonstrates a key principle of stream processing: historical CSV data replayed as if it were live. This is valid for prototyping because:</p> <ol> <li>The Pathway <code>mode=\"streaming\"</code> CSV reader tails files line-by-line, faithfully mimicking a live MPCB sensor feed</li> <li>All temporal operators (window joins, thresholds) use event time (the <code>time</code> column in the data), not wall-clock time \u2014 so replaying 13 days of data at filesystem speed produces correct results</li> <li>The evidence log is append-only \u2014 exactly as it would be in production</li> </ol> <p>This approach means the prototype can be demonstrated without any live sensor hardware, while the Pathway graph is production-ready for a live feed: simply point <code>CETP_DATA_DIR</code> at a directory where a live MPCB dump script is writing new rows.</p>"},{"location":"methodology/#phase-1-tripwire-detection","title":"Phase 1: Tripwire Detection","text":"<p>Why COD only?</p> <p>COD (Chemical Oxygen Demand) is the primary statutory compliance parameter under India's MPCB effluent discharge norms. BOD is slower and less sensitive at 1-minute resolution. TSS is used as a secondary confirmation signal but is not the primary alarm trigger.</p> <p>Threshold selection:</p> <p>The demo threshold of <code>200 mg/L</code> was chosen because: - The real CETP baseline is ~193 mg/L (mean from priya_cetp_i.csv) - The real data maximum is ~230 mg/L - A value of 200 catches the 206 genuine spikes without being below baseline</p> <p>In production, regulatory thresholds are typically 450 mg/L for treated effluent discharge. Adjust <code>COD_THRESHOLD</code> in <code>constants.py</code> or via environment variable.</p>"},{"location":"methodology/#phase-1-temporal-backtracking","title":"Phase 1: Temporal Backtracking","text":"<p>The attribution model relies on a fixed pipe travel time (15 minutes by default). When a CETP spike is detected at time T:</p> <ol> <li>Compute <code>T_backtrack = T \u2212 15 min</code></li> <li>Search all factory discharge records within a <code>\u00b12 min</code> tolerance window</li> <li>Select the factory with the maximum COD in that window as the attributed source</li> </ol> <p>This is a greedy, non-probabilistic attribution \u2014 intentionally simple for v1. The v2 upgrade path uses statistical weighting and chemical fingerprint matching (see <code>anti_cheat.py</code>).</p>"},{"location":"methodology/#factory-simulation-design","title":"Factory Simulation Design","text":"<p>Since only one real CETP CSV is available, four synthetic factory profiles were generated using the same 1-minute timestamp skeleton:</p> Factory Profile Test Target A Normal baseline (Gaussian, \u03c3=3 mg/L COD) False negative rate B Shock-load (450 mg/L spike at T-15min) Phase 1 attribution accuracy C Zero-variance (constant 115.00 mg/L) v2 digital tampering alarm D Blackout (20-min NA window at T-15min) v2 guilt-by-disconnection <p>The NA gap pattern (sensor fires every ~3 rows in the real data) is replicated in all factory CSVs to maintain MPCB transmission spec consistency.</p>"},{"location":"methodology/#streaming-vs-batch","title":"Streaming vs Batch","text":"Concern SHIELD AI approach Throughput Pathway batch-and-stream hybrid \u2014 handles 18K+ rows in seconds Latency Configurable <code>autocommit_duration_ms</code> (default 1000ms) Fault tolerance JSONL log is append-only; Pathway persists state between restarts Backpressure Pathway's internal scheduler handles CSV tail lag"},{"location":"ml_roadmap/","title":"ML Roadmap","text":"<p>Phase 1 uses deterministic rule-based detection. This page outlines the planned ML extensions for v2 and beyond.</p>"},{"location":"ml_roadmap/#ml-1-anomaly-scoring-with-isolation-forest","title":"ML-1: Anomaly Scoring with Isolation Forest","text":"<p>Problem: The threshold-based tripwire fires on all COD readings \u2265 \u03b8, regardless of whether the spike is part of a seasonal pattern or a genuine illegal dump.</p> <p>Approach: - Train an <code>IsolationForest</code> (scikit-learn) on the pre-existing 13 days of CETP data - Score each incoming CETP reading; outlier score &gt; 0.5 \u2192 fire the alarm - Advantage: adapts to natural COD variability (monsoon vs dry season)</p> <p>Data requirement: 90+ days of baseline CETP data (currently have 13 days)</p> <pre><code>from sklearn.ensemble import IsolationForest\n\nmodel = IsolationForest(contamination=0.02, random_state=42)\nmodel.fit(cetp_baseline[[\"cetp_inlet_cod\", \"cetp_inlet_tss\"]])\nscores = model.decision_function(live_window)\n</code></pre>"},{"location":"ml_roadmap/#ml-2-multi-factory-attribution-probability","title":"ML-2: Multi-Factory Attribution Probability","text":"<p>Problem: The greedy <code>max(factory.COD)</code> rule fails when multiple factories dump simultaneously.</p> <p>Approach: - Train a multi-label classifier on historical (factory, CETP spike) pairs - Features: <code>[factory_cod, factory_tss, factory_bod, pipe_distance, time_of_day, day_of_week]</code> - Output: probability distribution over factories for each CETP event</p> <p>Model: Gradient Boosted Trees (XGBoost) or a multinomial logistic regression baseline</p>"},{"location":"ml_roadmap/#ml-3-dynamic-pipe-travel-time-prediction","title":"ML-3: Dynamic Pipe Travel Time Prediction","text":"<p>Problem: Pipe travel time is fixed at 15 min (v1 assumption). Flow rate varies with upstream load, season, and rainfall.</p> <p>Approach: - Collect flow-rate sensor readings from junction boxes - Train a regression model: <code>\u03c4_travel = f(flow_rate, pipe_fill_level, rainfall_mm)</code> - Replace the constant in <code>constants.py</code> with the model's live prediction</p> <p>Data requirement: Junction flow-rate sensors (currently not available in the prototype)</p>"},{"location":"ml_roadmap/#ml-4-zero-variance-detection-via-cusum","title":"ML-4: Zero-Variance Detection via CUSUM","text":"<p>Problem: The v2 zero-variance rule (\u03c3 = 0) only catches perfectly flat sensors. A more subtle tamper gradually reduces COD to avoid detection.</p> <p>Approach: - CUSUM (Cumulative Sum) change-point detection on factory COD time series - Flags any sustained downward trend that is statistically inconsistent with the baseline</p> <pre><code>from ruptures import Pelt\nmodel = Pelt(model=\"rbf\").fit(factory_cod_series)\nchangepoints = model.predict(pen=10)\n</code></pre>"},{"location":"ml_roadmap/#ml-5-seasonal-baseline-adaptation","title":"ML-5: Seasonal Baseline Adaptation","text":"<p>Problem: <code>COD_BASELINE = 193.0</code> is computed from one month of data. The true baseline shifts with industrial cycles, monsoon dilution, and upstream CETP load.</p> <p>Approach: - Maintain a rolling 30-day exponential moving average of CETP baseline COD - Update <code>COD_BASELINE</code> dynamically in the Pathway graph via <code>pw.apply_with_context</code></p>"},{"location":"ml_roadmap/#implementation-priority","title":"Implementation Priority","text":"Phase Feature Complexity Impact v2 Zero-variance CUSUM (ML-4) Low High v2 Dynamic baseline (ML-5) Low Medium v3 Isolation Forest scoring (ML-1) Medium High v3 Attribution probabilities (ML-2) High Very High v3 Dynamic pipe travel time (ML-3) High High"}]}